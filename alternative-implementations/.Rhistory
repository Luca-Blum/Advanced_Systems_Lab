for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
data = read.csv("../test_matrices/observations.csv")+1
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = matrix(1, M, M)
A = A/rowSums(A)
B = matrix(1:6, M, K)
B = B/rowSums(B)
initial_distribution = c(1/2, 1/2)
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data$X0
alpha = forward(v, a, b, initial_distribution)
alpha
#source:
# https://github.com/adeveloperdiary/HiddenMarkovModel
forward = function(v, a, b, initial_distribution){
T = length(v)
M = nrow(a)
alpha = matrix(0, T, M)
alpha[1, ] = initial_distribution*b[, v[1]]
for(t in 2:T){
tmp = alpha[t-1, ] %*% a
alpha[t, ] = tmp * b[, v[t]]
}
return(alpha)
}
backward = function(v, a, b){
T = length(v)
M = nrow(a)
beta = matrix(1, T, M)
for(t in (T-1):1){
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
beta[t, ] = t(a %*% tmp)
}
return(beta)
}
BaumWelch = function(v, a, b, initial_distribution, n.iter = 100){
for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
data = read.csv("../test_matrices/observations.csv")+1
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = matrix(1, M, M)
A = A/rowSums(A)
B = matrix(1:6, M, K)
B = B/rowSums(B)
initial_distribution = c(1/2, 1/2)
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data$X0
alpha = forward(v, a, b, initial_distribution)
alpha
initial_distribution
b[,v[1]]
t(alpha)
alpha[1,] %*% a
alpha[1,] %*% a * b[,v[z]]
alpha[1,] %*% a * b[,v[2]]
a
b[,v[2]]
b[,v[0]]
b
b[,v[2]]
v[2]
v[1]
v
data = read.csv("../test_matrices/observations.csv")+1
data
data = read.csv("../test_matrices/observations.csv",header = FALSE)+1
data
#source:
# https://github.com/adeveloperdiary/HiddenMarkovModel
forward = function(v, a, b, initial_distribution){
T = length(v)
M = nrow(a)
alpha = matrix(0, T, M)
alpha[1, ] = initial_distribution*b[, v[1]]
for(t in 2:T){
tmp = alpha[t-1, ] %*% a
alpha[t, ] = tmp * b[, v[t]]
}
return(alpha)
}
backward = function(v, a, b){
T = length(v)
M = nrow(a)
beta = matrix(1, T, M)
for(t in (T-1):1){
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
beta[t, ] = t(a %*% tmp)
}
return(beta)
}
BaumWelch = function(v, a, b, initial_distribution, n.iter = 100){
for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data$X0
(myout = BaumWelch(stateProb, A, B, initial_distribution, n.iter = 1))
#source:
# https://github.com/adeveloperdiary/HiddenMarkovModel
forward = function(v, a, b, initial_distribution){
T = length(v)
M = nrow(a)
alpha = matrix(0, T, M)
alpha[1, ] = initial_distribution*b[, v[1]]
for(t in 2:T){
tmp = alpha[t-1, ] %*% a
alpha[t, ] = tmp * b[, v[t]]
}
return(alpha)
}
backward = function(v, a, b){
T = length(v)
M = nrow(a)
beta = matrix(1, T, M)
for(t in (T-1):1){
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
beta[t, ] = t(a %*% tmp)
}
return(beta)
}
BaumWelch = function(v, a, b, initial_distribution, n.iter = 100){
for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = stateProb
alpha = forward(v, a, b, initial_distribution)
initial_distribution
b
data = read.csv("../test_matrices/observations.csv",header = FALSE)+1
data
data = as.vector(unname(data))
data
data = read.csv("../test_matrices/observations.csv",header = FALSE)+1
data = as.vector(unname(data))
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data
alpha = forward(v, a, b, initial_distribution)
b
v
data = as.matrix((unname(data))
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data
data = as.matrix(unname(data))
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data
alpha = forward(v, a, b, initial_distribution)
alpha
v
a
#source:
# https://github.com/adeveloperdiary/HiddenMarkovModel
forward = function(v, a, b, initial_distribution){
T = length(v)
M = nrow(a)
alpha = matrix(0, T, M)
alpha[1, ] = initial_distribution*b[, v[1]]
for(t in 2:T){
tmp = alpha[t-1, ] %*% a
alpha[t, ] = tmp * b[, v[t]]
}
return(alpha)
}
backward = function(v, a, b){
T = length(v)
M = nrow(a)
beta = matrix(1, T, M)
for(t in (T-1):1){
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
beta[t, ] = t(a %*% tmp)
}
return(beta)
}
BaumWelch = function(v, a, b, initial_distribution, n.iter = 100){
for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
data = read.csv("../test_matrices/observations.csv",header = FALSE)+1
data = as.matrix(unname(data))
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data
alpha = forward(v, a, b, initial_distribution)
alpha
t(alpha)
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
beta
length(v)
b[,v[10]]
v
b[,v[10]]
b[,v[9]]
b[,v[8]]
a
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
tmp = as.matrix(beta[9, ] * b[, v[9]])
t(a %*% tmp)
beta = matrix(1, T, M)
tmp = as.matrix(beta[9, ] * b[, v[9]])
t(a %*% tmp)
T
tmp = as.matrix(beta[10, ] * b[, v[10]])
t(a %*% tmp)
tmp
beta[9,]=t(a %*% tmp)
tmp = as.matrix(beta[9, ] * b[, v[9]])
t(a %*% tmp)
beta
beta = backward(v, a, b)
beta
tmp
a
t(a %*% tmp)
beta[9,]*b[,v[9]]
beta[9,]
b[,v[9]]
a
beta = matrix(1, T, M)
beta[10,]
b[],v[t+1]]
b[],v[10]]
b[,v[10]]
tmp = as.matrix(beta[10,]*b[,v[10]])
tmp
a
t(a%*%tmp)
#source:
# https://github.com/adeveloperdiary/HiddenMarkovModel
forward = function(v, a, b, initial_distribution){
T = length(v)
M = nrow(a)
alpha = matrix(0, T, M)
alpha[1, ] = initial_distribution*b[, v[1]]
for(t in 2:T){
tmp = alpha[t-1, ] %*% a
alpha[t, ] = tmp * b[, v[t]]
}
return(alpha)
}
backward = function(v, a, b){
T = length(v)
M = nrow(a)
beta = matrix(1, T, M)
for(t in (T-1):1){
tmp = as.matrix(beta[t+1, ] * b[, v[t+1]])
beta[t, ] = t(a %*% tmp)
}
return(beta)
}
BaumWelch = function(v, a, b, initial_distribution, n.iter = 100){
for(i in 1:n.iter){
T = length(v)
M = nrow(a)
K=ncol(b)
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
xi = array(0, dim=c(M, M, T-1))
for(t in 1:T-1){
denominator = ((alpha[t,] %*% a) * b[,v[t+1]]) %*% matrix(beta[t+1,])
for(s in 1:M){
numerator = alpha[t,s] * a[s,] * b[,v[t+1]] * beta[t+1,]
xi[s,,t]=numerator/as.vector(denominator)
}
}
xi.all.t = rowSums(xi, dims = 2)
a = xi.all.t/rowSums(xi.all.t)
gamma = apply(xi, c(1, 3), sum)
gamma = cbind(gamma, colSums(xi[, , T-1]))
for(l in 1:K){
b[, l] = rowSums(gamma[, which(v==l)])
}
b = b/rowSums(b)
}
return(list(a = a, b = b, initial_distribution = initial_distribution))
}
data = read.csv("../test_matrices/observations.csv",header = FALSE)+1
data = as.matrix(unname(data))
emissionMatrix<- read.csv(file = '../test_matrices/emissionMatrix.csv',header=FALSE)
emissionMatrix<-as.matrix(unname(emissionMatrix))
transitionMatrix<- read.csv(file = '../test_matrices/transitionMatrix.csv',header=FALSE)
transitionMatrix<-as.matrix(unname(transitionMatrix))
stateProb<- read.csv(file = '../test_matrices/stateProb.csv',header=FALSE)
stateProb <-as.vector(t(unname(stateProb)))
#data = read.csv("data_r.csv")
M=2
K=3
A = transitionMatrix
B = emissionMatrix
initial_distribution = stateProb
b = B
a = A
v = data
alpha = forward(v, a, b, initial_distribution)
beta = backward(v, a, b)
alpha
beta
